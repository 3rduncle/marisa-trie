#summary インタフェース
#labels Featured

= はじめに =

libmarisa には，C++ 用のインタフェースと C 言語用のインタフェースがあります．すべての機能は C++ により実装されていて，それらに対するラッパとして C 言語用のインタフェースが提供されているという構成になっています．

 * *Version: 0.1.0 向けに修正中です．現在，エラー処理の部分だけが 0.1.0 の内容で，残りは 0.0.1 の内容になっています．ご注意ください．*

<wiki:toc max_depth="3" />

----

= エラー処理 =

C++ 用のインタフェースでは，エラーを検出したとき，例外 `marisa::Exception` を投げるようになっています．ただし，I/O において `std::iostream` が `std::ios_base::failure` 以外を投げた場合，およびにコールバック関数が `std::bad_alloc` もしくは `std::length_error` 以外の例外を投げた場合，それらの例外はライブラリ内部でキャッチされないので，呼び出し側で対処する必要があります．

一方，C 言語用のインタフェースでは，例外をライブラリの内部でキャッチし，エラー番号 `marisa_status` を返すようになっています．呼び出し側に例外が届くようなことはありません．あるとすれば，それはライブラリのバグです．

----

== 例外 ==

例外クラスである `marisa::Exception` には，`std::exception` と同じように関数 `what()` を持たせているほか，ファイル名，行番号，エラー番号を持たせるようにしています．

{{{
class Exception {
 public:
  Exception(const char *filename, int line, Status status);
  Exception(const Exception &ex);

  Exception &operator=(const Exception &rhs);

  // 例外を投げたファイルの名前（__FILE__）を返します．
  const char *filename() const;

  // 例外を投げた行の番号（__LINE__）を返します．
  int line() const;

  // エラー番号を返します．
  Status status() const;

  // エラー番号に対応する文字列を返します．
  // marisa_strerror() を呼び出すだけです．
  const char *what() const;
};
}}}

----

== エラー番号 ==

エラー番号の一覧は，列挙体 `marisa_status`（`marisa::Status` と同じ）のメンバとして定義されています．

{{{
typedef enum marisa_status_ {
  // C 言語用のインタフェース専用であり，問題がないときに返されます．
  MARISA_OK               = 0,

  // C 言語用のインタフェース専用であり，不正なハンドルを指定したときに
  // 返されます．
  MARISA_HANDLE_ERROR     = 1,

  // オブジェクトの状態と指定した動作の組み合わせが適切でないことを示す
  // エラーです．例えば，構築前の marisa::Trie オブジェクトで検索しようと
  // した場合に発生します．
  MARISA_STATE_ERROR      = 2,

  // 引数が正しくないときに起きるエラーです．NULL ポインタや範囲外の値を
  // 引数として渡したときに発生することがあります．
  MARISA_PARAM_ERROR      = 3,

  // 基本的には，入力されたキー集合が大きすぎるとき，あるいは検索結果が
  // 大きくなりすぎたときに起きるエラーです．`std::length_error' の代わり
  // として使っています．
  MARISA_SIZE_ERROR       = 4,

  // メモリの確保に失敗したことを示すエラーです．
  MARISA_MEMORY_ERROR     = 5,

  // 入出力に失敗したことを示すエラーです．
  MARISA_IO_ERROR         = 6,

  // 想定していないエラーです．ライブラリのバグである可能性があります．
  MARISA_UNEXPECTED_ERROR = 7
} marisa_status;
}}}

エラーの番号から名前を取得できるように，`marisa_strerror()` という関数を用意しています．引数が `MARISA_OK` であれば "MARISA_OK" を返すという程度の味気ない関数ですが，多少は役に立つと思います．

{{{
const char *marisa_strerror(marisa_status status);
}}}

----

= C++ 用のインタフェース =

libmarisa を利用するときは，`marisa.h` をインクルードし，`marisa::Trie` というクラスを用いることになります．また，キーの ID として使用する型（`unsigned __int32` もしくは `uint32_t`）には，`marisa::UInt32` という別名が与えられています．以下，`marisa::Trie` の解説になっています．対応するヘッダは `marisa/trie.h` です．

----

== コンストラクタ ==

{{{
Trie();
}}}

`marisa::Trie` のコンストラクタはメンバを初期化するだけであり，例外を投げることはありません．

----

== 構築 ==

=== `build()` ===

{{{
void build(const std::vector<const char *> &keys,
    std::vector<UInt32> *key_ids = NULL, UInt32 max_num_tries = 3,
    bool patricia = true, bool tail = true, bool freq_order = true);
void build(const std::vector<char *> &keys,
    std::vector<UInt32> *key_ids = NULL, UInt32 max_num_tries = 3,
    bool patricia = true, bool tail = true, bool freq_order = true);
void build(const std::vector<std::string> &keys,
    std::vector<UInt32> *key_ids = NULL, UInt32 max_num_tries = 3,
    bool patricia = true, bool tail = true, bool freq_order = true);
}}}

{{{
void build(const std::vector<std::pair<const char *, double> > &keys,
    std::vector<UInt32> *key_ids = NULL, UInt32 max_num_tries = 3,
    bool patricia = true, bool tail = true, bool weight_order = true);
void build(const std::vector<std::pair<char *, double> > &keys,
    std::vector<UInt32> *key_ids = NULL, UInt32 max_num_tries = 3,
    bool patricia = true, bool tail = true, bool weight_order = true);
void build(const std::vector<std::pair<std::string, double> > &keys,
    std::vector<UInt32> *key_ids = NULL, UInt32 max_num_tries = 3,
    bool patricia = true, bool tail = true, bool weight_order = true);
}}}

新しい辞書を構築します．構築の途中でメモリの確保に失敗した場合，オブジェクトには変更を加えず，`std::bad_alloc` を投げるようになっています．

第 1 引数の `keys` については，`const char *`, `char *`, `std::string`，およびに `double` との `std::pair` が使えるようになっています．`const char *` と `char *` は `NULL` 文字を終端として扱うので，バイナリのキーを渡すことはできません．バイナリのキーが必要なときは `std::string` を使ってください．`build()` は与えられたキー集合を内部で整列するようになっているので，あらかじめ整列しておく必要はありません．

※ バイナリのキーについては，一部制限があります．第 5 引数である `tail` の説明を参照してください．

第 2 引数の `key_ids` は，各キーに割り当てられた ID を受け取るための引数です．有効なポインタを渡しておけば，`keys[i]` のキー ID が `key_ids[i]` に格納されます．ID がいらないときは `NULL` を渡してください．

第 3 引数の `max_num_tries` は辞書を構成するトライの数を制限するための引数です．単語やフレーズの集合から辞書を構築するのであれば，デフォルトの引数である `3` が妥当な設定になることが経験的に分かっています．見出し語・品詞・読みなどをつなげて登録する場合，`10` 程度の大きな値を指定することにより，辞書のサイズをさらに小さくすることができます．適切な設定については，付属のツールである `marisa-benchmark` を使って調べることができます．

第 4 引数の `patricia` は，Patricia Trie と Prefix Trie の切り替えに関するフラグです．`true` であれば Patricia Trie になり，`false` であれば Prefix Trie になります．Patricia の方が優秀なので，あえて Prefix Trie に切り替える理由はほとんどありません．

第 5 引数の `tail` は，Prefix Trie および Prefix Trie に格納しきれなかった部分を文字列として持つか，Trie として持つかを切り替えるためのフラグです．`true` であれば文字列化し，`false` であればトライ化します．ただし，残りに `NULL` 文字が含まれている場合，`tail` が `true` であってもトライ化がおこなわれます．このとき，辞書を構成するトライの数が `max_num_tries + 1` になるので注意してください．

第 6 引数の `weight_order` は，ノードの並びを切り替えるためのフラグです．`true` であれば重み順になり，`false` であればラベル順になります．重みについては，`keys` の要素が `std::pair` であれば，`second` に格納されている値を使います． `std::pair` でなければ，各キーに対して `1.0` が与えられます．同じキーが複数ある場合，重みは加算されるようになっています．例えば，各キーの出現頻度を指定した上で重み順にすると，辿ることになりやすいノードを前方に配置し，検索時間を短縮することができます．

----

== 入出力 ==

=== `mmap()`, `map()` ===

{{{
bool mmap(Mapper *mapper, const char *filename,
    long offset = 0, int whence = SEEK_SET);
bool map(const void *ptr);
bool map(const void *ptr, std::size_t size);
bool map(Mapper *mapper);
}}}

Memory mapped I/O によりアドレス空間に割り当てられたデータやメモリ上に展開されたデータから辞書を復元します．データの変更やメモリの解放は致命的なエラーにつながるので注意してください．

`mmap()` は Memory mapped I/O により割り当てたデータを `mapper` に関連付けるようになっています．呼び出し側では，辞書だけでなく `mapper` も維持しておく必要があるので注意してください．

`offset` と `whence` は，`std::fseek()` の第 2 引数および第 3 引数と同じ役割を果たします．

=== `load()`, `read()` ===

{{{
bool load(const char *filename, long offset = 0, int whence = SEEK_SET);
bool read(int fd);
bool read(::FILE *file);
bool read(std::istream *stream);
bool read(Reader *reader);
}}}

辞書をファイルなどから入力します．入力元の指定には，ファイル名だけでなく，ファイルディスクリプタや `std::FILE *`, `std::istream *` も利用できます．

`offset` と `whence` は，ファイルを開いた後で呼び出す std::fseek() の第 2 引数と第 3 引数になります．

=== `save()`, `write()` ===

{{{
bool save(const char *filename, bool trunc_flag = true,
    long offset = 0, int whence = SEEK_SET) const;
bool write(int fd) const;
bool write(::FILE *file) const;
bool write(std::ostream *stream) const;
bool write(Writer *writer) const;
}}}

辞書をファイルなどに出力します．出力先の指定には，ファイル名だけでなく，ファイルディスクリプタや `std::FILE *`, `std::istream *` も利用できます．

`trunc_flag` はファイルの切り詰めをおこなうかどうかを指定するフラグです．`true` にであれば切り詰めをおこない，`false` であれば古い内容を残して上書きします．

`offset` と `whence` は，ファイルを開いた後で呼び出す `std::fseek()` の第 2 引数と第 3 引数になります．

----

== 検索 ==

=== `operator[]()` ===

{{{
std::string operator[](UInt32 key_id) const;
}}}

ID からキーを復元します．正体は `restore()` です．呼び出しのたびに `std::string` のオブジェクトを作成するので，オーバーヘッドが大きくなります．繰り返し呼び出す場合，第 2 引数を受け取る `restore()` の利用を検討してください．

{{{
UInt32 operator[](const char *str) const;
UInt32 operator[](const std::string &str) const;
}}}

キーから ID を求めます．正体は `lookup()` です．

=== `restore()` ===

{{{
std::string restore(UInt32 key_id) const;
void restore(UInt32 key_id, std::string *key) const;
}}}

ID からキーを復元します．範囲外の ID を指定したときの動作は未定義です．`std::string` のオブジェクトを返す前者の方が使いやすいものの，オーバーヘッドは大きくなります．パフォーマンスを重視するときは後者の利用を検討してください．

=== `lookup()` ===

{{{
UInt32 lookup(const char *str) const;
UInt32 lookup(const char *ptr, std::size_t length) const;
UInt32 lookup(const std::string &str) const;
}}}

キーから ID を求めます．未登録のキーを指定した場合，`lookup()` の返り値は `notfound()` の返り値（`NOTFOUND` も同じ）と等しくなります．

=== `find()`, `find_first()`, `find_last()` ===

{{{
UInt32 find(const char *str,
    std::vector<UInt32> *key_ids = NULL,
    std::vector<std::size_t> *key_lengths = NULL) const;
UInt32 find(const char *ptr, std::size_t length,
    std::vector<UInt32> *key_ids = NULL,
    std::vector<std::size_t> *key_lengths = NULL) const;
UInt32 find(const std::string &str,
    std::vector<UInt32> *key_ids = NULL,
    std::vector<std::size_t> *key_lengths = NULL) const;
}}}

指定された文字列の前方部分列と一致するキーを検索します．返り値は一致したキーの数です．一致するキーが見つかったときは，`key_ids` と `key_lengths` の末尾に，それぞれキーの ID と長さが追加されます．ID や長さがいらないときは `NULL` を渡してください．

{{{
UInt32 find_first(const char *str,
    std::size_t *key_length = NULL) const;
UInt32 find_first(const char *ptr, std::size_t length,
    std::size_t *key_length = NULL) const;
UInt32 find_first(const std::string &str,
    std::size_t *key_length = NULL) const;
}}}

指定された文字列の前方部分列と一致するキーを検索して，最初に見つかった（一番短い）キーの ID を返します．`key_length` が `NULL` でなければ，見つかったキーの長さが格納されるようになっています．見つからなければ，返り値は `NOTFOUND` になり，`key_length` は変更されません．

{{{
UInt32 find_last(const char *str,
    std::size_t *key_length = NULL) const;
UInt32 find_last(const char *ptr, std::size_t length,
    std::size_t *key_length = NULL) const;
UInt32 find_last(const std::string &str,
    std::size_t *key_length = NULL) const;
}}}

指定された文字列の前方部分列と一致するキーを検索して，最後に見つかった（一番長い）キーの ID を返します．`key_length` が `NULL` でなければ，見つかったキーの長さが格納されるようになっています．見つからなければ，返り値は `NOTFOUND` になり，`key_length` は変更されません．

=== `find_callback()` ===

{{{
// bool callback(UInt32 key_id, std::size_t key_length);
template <typename T>
UInt32 find_callback(const char *str, T callback) const;
template <typename T>
UInt32 find_callback(const char *ptr, std::size_t length,
    T callback) const;
template <typename T>
UInt32 find_callback(const std::string &str, T callback) const;
}}}

指定された文字列の前方部分列と一致するキーを検索し，キーが見つかるたびにコールバック関数を呼び出します．コールバック関数の第 1 引数にはキーの ID，第 2 引数にはキーの長さが渡されます．また，コールバック関数の返り値が `0` あるいは `false` であれば，検索を中断します．返り値はコールバック関数を呼び出した回数になります．

=== `predict()` ===

{{{
UInt32 predict(const char *str,
    std::vector<UInt32> *key_ids = NULL) const;
UInt32 predict(const char *ptr, std::size_t length,
    std::vector<UInt32> *key_ids = NULL) const;
UInt32 predict(const std::string &str,
    std::vector<UInt32> *key_ids = NULL) const;
}}}

指定された文字列で始まるキーの数を返します．該当するキーの ID が `key_ids` に追加されるようになっています．ID がいらないときは `key_ids` を `NULL` にしてください．

キーを復元する必要がないという特徴を利用して，手抜きな探索をおこないます．結果として，`key_ids` に追加される ID は幅優先（昇順）になります．後述の `predict()` と比べると，機能は制限されるものの，探索時間は短くなります．

深さ優先な ID が欲しいときやキーを復元したいときは，後述の `predict()` を利用してください．

{{{
UInt32 predict(const char *str,
    std::vector<UInt32> *key_ids, std::vector<std::string> *keys) const;
UInt32 predict(const char *ptr, std::size_t length,
    std::vector<UInt32> *key_ids, std::vector<std::string> *keys) const;
UInt32 predict(const std::string &str,
    std::vector<UInt32> *key_ids, std::vector<std::string> *keys) const;
}}}

指定された文字列で始まるキーの数を返します．該当するキーの ID が `key_ids` に追加されるだけでなく，復元されたキーが `keys` に追加されるようになっています．ID がいらないときは `key_ids` を `NULL` に，キーがいらないときは `keys` を `NULL` にしてください．

=== `predict_callback()` ===

{{{
// bool callback(UInt32 key_id, const std::string &key);
template <typename T>
UInt32 predict_callback(const char *str, T callback) const;
template <typename T>
UInt32 predict_callback(const char *ptr, std::size_t length,
    T callback) const;
template <typename T>
UInt32 predict_callback(const std::string &str, T callback) const;
}}}

指定された文字列で始まるキーを求めて辞書を探索し，該当するキーが見つかるたびにコールバック関数を呼び出します．コールバック関数の第 1 引数にはキーの ID，第 2 引数には復元されたキーが渡されます．また，コールバック関数の返り値が `0` あるいは `false` であれば，探索を中断します．返り値はコールバック関数を呼び出した回数になります．

----

== その他 ==

=== `num_keys()`, `num_tries()`, `num_nodes()`, `size()` ===

{{{
UInt32 num_keys() const;
UInt32 num_tries() const;
UInt32 num_nodes() const;
std::size_t size() const;
}}}

それぞれ，キー数，トライ数，ノード数，ファイルに出力したときのサイズ（バイト数）を返します．

=== `clear()`, `swap()` ===

{{{
void clear();
}}}

辞書の内容を破棄し，初期状態に戻します．実際には，新しいオブジェクトを作成して，そのオブジェクトと現在のオブジェクトの内容を交換するようになっています．

{{{
void swap(Trie *rhs);
}}}

オブジェクトの中身を交換します．例外は発生しないようになっています．

=== `notfound()`, `mismatch()` ===

{{{
static UInt32 notfound();
static std::size_t mismatch();

static const UInt32 NOTFOUND = static_cast<UInt32>(-1);
static const std::size_t MISMATCH = static_cast<std::size_t>(-2);
}}}

`notfound()` と `mismatch()` は，それぞれ `NOTFOUND` と `MISMATCH` を返します．`NOTFOUND` と `notfound()` のどちらを使うのかは気分次第です．

`NOTFOUND` はキーが見つからなかったことを示す定数です．`MISMATCH` は，内部で使用されている定数であり，今のところ，外部からは用なしの存在です．

----

= C 言語用のインタフェース ==

まだですよー．
